generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model agent_accounts {
  id            String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agent_id      String      @db.Uuid
  ct_account_id String      @db.Uuid
  created_at    DateTime    @default(now()) @db.Timestamptz(6)
  agents        agents      @relation(fields: [agent_id], references: [id], onDelete: Cascade)
  ct_accounts   ct_accounts @relation(fields: [ct_account_id], references: [id], onDelete: Cascade)

  @@unique([agent_id, ct_account_id])
  @@index([agent_id])
  @@index([ct_account_id])
}

model agent_telegram_users {
  id                    String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agent_id              String                 @db.Uuid
  telegram_alpha_user_id String                @db.Uuid
  created_at            DateTime               @default(now()) @db.Timestamptz(6)
  agents                agents                 @relation(fields: [agent_id], references: [id], onDelete: Cascade)
  telegram_alpha_users  telegram_alpha_users   @relation(fields: [telegram_alpha_user_id], references: [id], onDelete: Cascade)

  @@unique([agent_id, telegram_alpha_user_id])
  @@index([agent_id])
  @@index([telegram_alpha_user_id])
}

model user_agent_addresses {
  id                              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_wallet                     String    @unique
  hyperliquid_agent_address       String?   @unique
  hyperliquid_agent_key_encrypted String?
  hyperliquid_agent_key_iv        String?
  hyperliquid_agent_key_tag       String?
  ostium_agent_address            String?   @unique
  ostium_agent_key_encrypted      String?
  ostium_agent_key_iv             String?
  ostium_agent_key_tag            String?
  created_at                      DateTime  @default(now()) @db.Timestamptz(6)
  last_used_at                    DateTime? @db.Timestamptz(6)

  @@index([user_wallet])
  @@index([hyperliquid_agent_address])
  @@index([ostium_agent_address])
}

model user_trading_preferences {
  id                        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_wallet               String    @unique
  risk_tolerance            Int       @default(50)
  trade_frequency           Int       @default(50)
  social_sentiment_weight   Int       @default(50)
  price_momentum_focus      Int       @default(50)
  market_rank_priority      Int       @default(50)
  created_at                DateTime  @default(now()) @db.Timestamptz(6)
  updated_at                DateTime  @updatedAt @db.Timestamptz(6)

  @@index([user_wallet])
}

model agent_deployments {
  id                              String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agent_id                        String              @db.Uuid
  user_wallet                     String
  safe_wallet                     String
  status                          deployment_status_t @default(ACTIVE)
  sub_active                      Boolean             @default(true)
  sub_started_at                  DateTime            @default(now()) @db.Timestamptz(6)
  trial_ends_at                   DateTime?           @db.Timestamptz(6)
  next_billing_at                 DateTime?           @db.Timestamptz(6)
  module_enabled                  Boolean             @default(false)
  module_address                  String?
  enabled_venues                  String[]            @default(["HYPERLIQUID"])
  risk_tolerance                  Int                 @default(50)
  trade_frequency                 Int                 @default(50)
  social_sentiment_weight         Int                 @default(50)
  price_momentum_focus            Int                 @default(50)
  market_rank_priority            Int                 @default(50)
  agents                          agents              @relation(fields: [agent_id], references: [id], onDelete: Cascade)
  billing_events                  billing_events[]
  pnl_snapshots                   pnl_snapshots[]
  positions                       positions[]
  signals                         signals[]
  telegram_trades                 telegram_trades[]
  telegram_users                  telegram_users[]

  @@index([agent_id])
  @@index([user_wallet])
  @@index([user_wallet, agent_id])
}

model agent_research_institutes {
  id                  String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agent_id            String              @db.Uuid
  institute_id        String              @db.Uuid
  created_at          DateTime            @default(now()) @db.Timestamptz(6)
  agents              agents              @relation(fields: [agent_id], references: [id], onDelete: Cascade)
  research_institutes research_institutes @relation(fields: [institute_id], references: [id], onDelete: Cascade)

  @@unique([agent_id, institute_id])
  @@index([agent_id])
  @@index([institute_id])
}

model agent_routing_history {
  id                  String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  signal_id           String?   @db.Uuid
  requested_venues    String[]
  selected_venue      venue_t?
  routing_reason      String?
  checked_venues      String[]
  venue_availability  Json?
  routing_duration_ms Int?
  created_at          DateTime? @default(now()) @db.Timestamptz(6)
  signals             signals?  @relation(fields: [signal_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([created_at], map: "idx_routing_history_created")
  @@index([signal_id], map: "idx_routing_history_signal")
  @@index([selected_venue], map: "idx_routing_history_venue")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model agents {
  id                        String                      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  creator_wallet            String
  name                      String
  venue                     venue_t
  weights                   Int[]                       @db.SmallInt
  apr_30d                   Float?                      @db.Real
  apr_90d                   Float?                      @db.Real
  apr_si                    Float?                      @db.Real
  sharpe_30d                Float?                      @db.Real
  profit_receiver_address   String
  proof_of_intent_message   String?
  proof_of_intent_signature String?
  proof_of_intent_timestamp DateTime?                   @db.Timestamptz(6)
  status                    agent_status_t?             @default(PUBLIC)
  agent_accounts            agent_accounts[]
  agent_deployments         agent_deployments[]
  agent_research_institutes agent_research_institutes[]
  agent_telegram_users      agent_telegram_users[]
  impact_factor_history     impact_factor_history[]
  pnl_snapshots             pnl_snapshots[]
  signals                   signals[]
  venue_routing_config      venue_routing_config?
}

model audit_logs {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  event_name   String
  subject_type String?
  subject_id   String?  @db.Uuid
  payload      Json?
  occurred_at  DateTime @default(now()) @db.Timestamptz(6)
  trace_id     String?

  @@index([event_name, occurred_at])
}

model billing_events {
  id                String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  position_id       String?           @db.Uuid
  deployment_id     String            @db.Uuid
  kind              bill_kind_t
  amount            Decimal           @db.Decimal(20, 8)
  asset             String            @default("USDC")
  status            bill_status_t
  occurred_at       DateTime          @default(now()) @db.Timestamptz(6)
  metadata          Json?
  agent_deployments agent_deployments @relation(fields: [deployment_id], references: [id], onDelete: Cascade)
  positions         positions?        @relation(fields: [position_id], references: [id])

  @@index([deployment_id, occurred_at])
  @@index([kind, occurred_at])
}

model ct_accounts {
  id                    String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  x_username            String                  @unique
  display_name          String?
  followers_count       Int?
  impact_factor         Float                   @default(0) @db.Real
  last_seen_at          DateTime?               @db.Timestamptz(6)
  is_active             Boolean                 @default(false)
  agent_accounts        agent_accounts[]
  ct_posts              ct_posts[]
  impact_factor_history impact_factor_history[]

  @@index([is_active])
}

model ct_posts {
  id                    String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  ct_account_id         String      @db.Uuid
  tweet_id              String      @unique
  tweet_text            String
  tweet_created_at      DateTime    @db.Timestamptz(6)
  is_signal_candidate   Boolean?
  extracted_tokens      String[]    @default([])
  confidence_score      Float?
  processed_for_signals Boolean     @default(false)
  signal_type           String?
  ct_accounts           ct_accounts @relation(fields: [ct_account_id], references: [id], onDelete: Cascade)

  @@index([ct_account_id])
  @@index([is_signal_candidate, processed_for_signals])
}

model impact_factor_history {
  id               String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  ct_account_id    String      @db.Uuid
  signal_id        String?     @db.Uuid
  position_id      String?     @db.Uuid
  pnl_contribution Decimal?    @db.Decimal(20, 8)
  weight           Float?      @db.Real
  model_version    String?
  occurred_at      DateTime    @default(now()) @db.Timestamptz(6)
  agent_id         String?     @db.Uuid
  agents           agents?     @relation(fields: [agent_id], references: [id])
  ct_accounts      ct_accounts @relation(fields: [ct_account_id], references: [id], onDelete: Cascade)
  positions        positions?  @relation(fields: [position_id], references: [id])
  signals          signals?    @relation(fields: [signal_id], references: [id])

  @@index([ct_account_id, occurred_at])
}

model market_indicators_6h {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  token_symbol String
  window_start DateTime @db.Timestamptz(6)
  indicators   Json

  @@unique([token_symbol, window_start])
  @@index([token_symbol])
}

model pnl_snapshots {
  id                String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agent_id          String            @db.Uuid
  deployment_id     String            @db.Uuid
  day               DateTime          @db.Date
  pnl               Decimal?          @db.Decimal(20, 8)
  return_pct        Float?            @db.Real
  agents            agents            @relation(fields: [agent_id], references: [id], onDelete: Cascade)
  agent_deployments agent_deployments @relation(fields: [deployment_id], references: [id], onDelete: Cascade)

  @@unique([deployment_id, day])
  @@index([agent_id, day])
}

model positions {
  id                    String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  deployment_id         String                  @db.Uuid
  signal_id             String                  @db.Uuid
  venue                 venue_t
  token_symbol          String
  side                  String
  qty                   Decimal                 @db.Decimal(20, 8)
  entry_price           Decimal                 @db.Decimal(20, 8)
  stop_loss             Decimal?                @db.Decimal(20, 8)
  take_profit           Decimal?                @db.Decimal(20, 8)
  trailing_params       Json?
  opened_at             DateTime                @default(now()) @db.Timestamptz(6)
  closed_at             DateTime?               @db.Timestamptz(6)
  exit_price            Decimal?                @db.Decimal(20, 8)
  pnl                   Decimal?                @db.Decimal(20, 8)
  entry_tx_hash         String?
  exit_tx_hash          String?
  manual_trade_id       String?                 @db.Uuid
  source                String                  @default("auto")
  current_price         Decimal?                @db.Decimal(20, 8)
  exit_reason           String?
  status                String                  @default("OPEN")
  ostium_trade_index    Int?                   // Actual trade index from Ostium (fixes SDK bug)
  ostium_trade_id       String?                // Order ID / Trade ID from Ostium SDK for precise matching
  billing_events        billing_events[]
  impact_factor_history impact_factor_history[]
  agent_deployments     agent_deployments       @relation(fields: [deployment_id], references: [id], onDelete: Cascade)
  telegram_trades       telegram_trades?        @relation(fields: [manual_trade_id], references: [id])
  signals               signals                 @relation(fields: [signal_id], references: [id], onDelete: Cascade)

  @@unique([deployment_id, signal_id])
  @@index([deployment_id, opened_at])
  @@index([signal_id])
  @@index([source])
  @@index([status])
}

model research_institutes {
  id                        String                      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                      String                      @unique
  description               String?
  logo_url                  String?
  website_url               String?
  x_handle                  String?
  telegram_handle           String?
  is_active                 Boolean                     @default(true)
  created_at                DateTime                    @default(now()) @db.Timestamptz(6)
  agent_research_institutes agent_research_institutes[]
  research_signals          research_signals[]
  telegram_sources          telegram_sources[]
}

model research_signals {
  id                   String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  institute_id         String              @db.Uuid
  signal_text          String
  source_url           String?
  extracted_tokens     String[]            @default([])
  signal_type          String?
  extracted_leverage   Int?
  is_signal_candidate  Boolean?
  confidence_score     Float?
  processed_for_signals Boolean             @default(false)
  created_at           DateTime            @default(now()) @db.Timestamptz(6)
  research_institutes  research_institutes @relation(fields: [institute_id], references: [id], onDelete: Cascade)

  @@index([institute_id, created_at])
  @@index([is_signal_candidate])
  @@index([processed_for_signals])
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
/// Expression index: signals_agent_token_deployment_bucket_6h_idx on (agent_id, token_symbol, deployment_id, bucket_6h_utc(created_at))
model signals {
  id                           String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agent_id                     String                  @db.Uuid
  deployment_id                String?                 @db.Uuid
  token_symbol                 String
  venue                        venue_t
  side                         String
  size_model                   Json
  risk_model                   Json
  source_tweets                String[]                @default([])
  created_at                   DateTime                @default(now()) @db.Timestamptz(6)
  skipped_reason               String?
  proof_verification_error     String?
  proof_verified               Boolean                 @default(false)
  executor_agreement_error     String?
  executor_agreement_message   String?
  executor_agreement_signature String?
  executor_agreement_timestamp DateTime?               @db.Timestamptz(6)
  executor_agreement_verified  Boolean                 @default(false)
  executor_wallet              String?
  lunarcrush_breakdown         Json?
  lunarcrush_reasoning         String?
  lunarcrush_score             Float?
  llm_decision                 String?
  llm_should_trade             Boolean?
  llm_fund_allocation          Float?
  llm_leverage                Float?
  trade_executed               String?
  execution_result             String?
  routing_history              Json?
  agent_routing_history        agent_routing_history[]
  impact_factor_history        impact_factor_history[]
  positions                    positions[]
  agents                       agents                  @relation(fields: [agent_id], references: [id], onDelete: Cascade)
  agent_deployments            agent_deployments?      @relation(fields: [deployment_id], references: [id], onDelete: Cascade)
  venue_routing_history        venue_routing_history[]

  @@index([agent_id, created_at])
  @@index([deployment_id])
  @@index([lunarcrush_score])
}

model telegram_alpha_users {
  id                    String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  telegram_user_id      String                  @unique
  telegram_username     String?
  first_name            String?
  last_name             String?
  impact_factor         Float                   @default(0.5) @db.Real
  is_active             Boolean                 @default(true)
  lazy_trader           Boolean                 @default(false)
  public_source         Boolean                 @default(false)
  user_wallet           String?                 // Wallet address for lazy traders (links telegram to wallet)
  last_message_at       DateTime?               @db.Timestamptz(6)
  created_at            DateTime                @default(now()) @db.Timestamptz(6)
  agent_telegram_users  agent_telegram_users[]
  telegram_posts        telegram_posts[]

  @@index([is_active])
  @@index([telegram_user_id])
  @@index([lazy_trader])
  @@index([public_source])
  @@index([user_wallet])
}

model telegram_sources {
  id                  String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  institute_id        String?              @db.Uuid
  source_name         String               @unique
  telegram_id         String?              @unique
  telegram_username   String?              @unique
  source_type         telegram_source_t    @default(CHANNEL)
  is_active           Boolean              @default(true)
  description         String?
  created_at          DateTime             @default(now()) @db.Timestamptz(6)
  last_fetched_at     DateTime?            @db.Timestamptz(6)
  research_institutes research_institutes? @relation(fields: [institute_id], references: [id], onDelete: SetNull)
  telegram_posts      telegram_posts[]

  @@index([is_active])
  @@index([institute_id])
}

model telegram_posts {
  id                      String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  source_id               String?               @db.Uuid
  alpha_user_id           String?               @db.Uuid
  message_id              String                @unique
  message_text            String
  message_created_at      DateTime              @db.Timestamptz(6)
  sender_id               String?
  sender_username         String?
  is_signal_candidate     Boolean?
  extracted_tokens        String[]              @default([])
  confidence_score        Float?
  signal_type             String?
  token_price             Float?               // Spot price from LunarCrush at classification time
  timeline_window         String?              // Parsed time window / deadline for the signal (e.g. "2025-01-31" or textual)
  take_profit             Float?   @default(0) // Take profit target extracted from signal
  stop_loss               Float?   @default(0) // Stop loss target extracted from signal
  impact_factor_flag      Boolean              @default(false) // Whether this signal has been used for impact-factor updates
  pnl                     Float                @default(0) @db.Real // Profit & Loss percentage (calculated from token_price vs current price)
  processed_for_signals   Boolean               @default(false)
  created_at              DateTime              @default(now()) @db.Timestamptz(6)
  
  // EigenAI Signature Verification Fields
  llm_signature           String?               // Cryptographic signature from EigenAI
  llm_raw_output          String?               // Full raw output from LLM (for verification)
  llm_model_used          String?               // Model ID used (e.g., "gpt-oss-120b-f16")
  llm_chain_id            Int?                  // Chain ID for signature verification
  llm_reasoning           String?               // LLM reasoning for classification
  llm_market_context      String?               // Market context string used in the prompt (for signature verification)
  llm_full_prompt         String?               // Full prompt (system + user) sent to LLM (for signature verification)
  max_favorable_excursion  Decimal? @db.Decimal(10, 4)  // Track max MFE over lifetime
  max_adverse_excursion    Decimal? @db.Decimal(10, 4)  // Track max MAE over lifetime
  impact_factor  Decimal? @default(0) @db.Decimal(10, 4)  // Store final impact factor
  
  telegram_sources        telegram_sources?     @relation(fields: [source_id], references: [id], onDelete: Cascade)
  telegram_alpha_users    telegram_alpha_users? @relation(fields: [alpha_user_id], references: [id], onDelete: Cascade)

  @@index([source_id])
  @@index([alpha_user_id])
  @@index([is_signal_candidate])
  @@index([message_created_at])
  @@index([processed_for_signals])
}

model telegram_trades {
  id                String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  telegram_user_id  String            @db.Uuid
  deployment_id     String            @db.Uuid
  message_id        String
  command           String
  parsed_intent     Json
  confirmed         Boolean           @default(false)
  confirmed_at      DateTime?         @db.Timestamptz(6)
  executed          Boolean           @default(false)
  executed_at       DateTime?         @db.Timestamptz(6)
  signal_id         String?           @db.Uuid
  status            String            @default("pending")
  error_message     String?
  created_at        DateTime          @default(now()) @db.Timestamptz(6)
  positions         positions[]
  agent_deployments agent_deployments @relation(fields: [deployment_id], references: [id], onDelete: Cascade)
  telegram_users    telegram_users    @relation(fields: [telegram_user_id], references: [id], onDelete: Cascade)

  @@index([deployment_id])
  @@index([status])
  @@index([telegram_user_id])
}

model telegram_users {
  id                String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  telegram_user_id  String            @unique
  telegram_username String?
  first_name        String?
  deployment_id     String            @db.Uuid
  link_code         String?           @unique
  linked_at         DateTime          @default(now()) @db.Timestamptz(6)
  last_active_at    DateTime          @default(now()) @db.Timestamptz(6)
  is_active         Boolean           @default(true)
  telegram_trades   telegram_trades[]
  agent_deployments agent_deployments @relation(fields: [deployment_id], references: [id], onDelete: Cascade)

  @@index([deployment_id])
}

model token_registry {
  id               String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chain            String
  token_symbol     String
  token_address    String
  preferred_router String?

  @@unique([chain, token_symbol])
}

model user_hyperliquid_wallets {
  id                          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_wallet                 String    @unique
  agent_address               String    @unique
  agent_private_key_encrypted String
  agent_key_iv                String
  agent_key_tag               String
  created_at                  DateTime  @default(now()) @db.Timestamptz(6)
  last_used_at                DateTime? @db.Timestamptz(6)
  is_approved                 Boolean   @default(false)

  @@index([agent_address])
  @@index([user_wallet])
}

model venue_markets {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  venue         venue_t
  token_symbol  String
  market_name   String
  market_index  Int?
  is_active     Boolean  @default(true)
  min_position  Decimal? @db.Decimal(20, 8)
  max_leverage  Int?
  group         String?
  current_price Decimal? @db.Decimal(20, 8)
  last_synced   DateTime @default(now()) @db.Timestamptz(6)
  metadata      Json?

  @@unique([venue, token_symbol])
  @@index([last_synced])
  @@index([venue, is_active])
  @@index([venue, token_symbol])
}

model ostium_available_pairs {
  id                  Int       @id
  symbol              String
  max_leverage        Float?
  maker_max_leverage  Float?
  group               String?
  created_at          DateTime  @default(now()) @db.Timestamptz(6)
  updated_at          DateTime  @updatedAt @db.Timestamptz(6)

  @@index([group])
}

model venue_routing_config {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agent_id         String?  @unique @db.Uuid
  venue_priority   String[]
  routing_strategy String   @default("FIRST_AVAILABLE")
  failover_enabled Boolean  @default(true)
  created_at       DateTime @default(now()) @db.Timestamptz(6)
  updated_at       DateTime @default(now()) @db.Timestamptz(6)
  agents           agents?  @relation(fields: [agent_id], references: [id], onDelete: Cascade)

  @@index([agent_id])
}

model venue_routing_history {
  id                  String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  signal_id           String   @db.Uuid
  token_symbol        String
  requested_venue     venue_t
  selected_venue      venue_t
  routing_reason      String
  checked_venues      String[]
  venue_availability  Json
  routing_duration_ms Int?
  created_at          DateTime @default(now()) @db.Timestamptz(6)
  signals             signals  @relation(fields: [signal_id], references: [id], onDelete: Cascade)

  @@index([created_at])
  @@index([signal_id])
  @@index([token_symbol, selected_venue])
}

model venues_status {
  id                 String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  venue              venue_t
  token_symbol       String
  min_size           Decimal? @db.Decimal(20, 8)
  tick_size          Decimal? @db.Decimal(20, 8)
  slippage_limit_bps Int?

  @@unique([venue, token_symbol])
  @@index([venue, token_symbol])
}

model wallet_pool {
  id                      String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  address                 String    @unique
  private_key             String
  assigned_to_user_wallet String?
  created_at              DateTime? @default(now()) @db.Timestamptz(6)
}

model user_telegram_notifications {
  id                String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_wallet       String    @unique
  telegram_chat_id  String    @unique
  telegram_username String?
  telegram_user_id  String?
  link_code         String?   @unique
  is_active         Boolean   @default(true)
  linked_at         DateTime  @default(now()) @db.Timestamptz(6)
  last_notified_at  DateTime? @db.Timestamptz(6)
  notification_logs notification_logs[]

  @@index([user_wallet])
  @@index([telegram_chat_id])
  @@index([link_code])
}

model notification_logs {
  id                              String                       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_wallet                     String
  position_id                     String?                      @db.Uuid
  signal_id                       String?                      @db.Uuid
  notification_type               notification_type_t
  message_content                 String?
  telegram_message_id             String?
  status                          notification_status_t        @default(PENDING)
  error_message                   String?
  sent_at                         DateTime?                    @db.Timestamptz(6)
  created_at                      DateTime                     @default(now()) @db.Timestamptz(6)
  user_telegram_notifications     user_telegram_notifications? @relation(fields: [user_wallet], references: [user_wallet], onDelete: Cascade)

  @@index([user_wallet, created_at])
  @@index([position_id])
  @@index([signal_id])
  @@index([notification_type, status])
  @@index([created_at])
}

/// Temporary cache table for lazy trading link codes
/// Maps link codes to wallet addresses so the webhook knows which wallet the telegram belongs to
/// Entries expire after 10 minutes
model lazy_trading_link_cache {
  link_code   String   @id @db.VarChar(50)
  user_wallet String   @db.VarChar(255)
  expires_at  DateTime @db.Timestamptz(6)
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  @@index([expires_at])
  @@index([user_wallet])
}

enum agent_status_t {
  DRAFT
  PUBLIC
  PRIVATE
}

enum bill_kind_t {
  SUBSCRIPTION
  INFRA_FEE
  PROFIT_SHARE
}

enum bill_status_t {
  CHARGED
  FAILED
}

enum deployment_status_t {
  ACTIVE
  PAUSED
  CANCELLED
}

enum telegram_source_t {
  CHANNEL
  GROUP
  USER
}

enum venue_t {
  SPOT
  GMX
  HYPERLIQUID
  OSTIUM
  MULTI
}

enum notification_type_t {
  SIGNAL_EXECUTED      // Signal resulted in a position
  SIGNAL_NOT_TRADED    // Signal generated but not traded
  POSITION_CLOSED
  STOP_LOSS_HIT
  TAKE_PROFIT_HIT
}

enum notification_status_t {
  PENDING
  SENT
  FAILED
}
